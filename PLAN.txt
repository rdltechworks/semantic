# Chronicles of the Synergistic Sphere - Detailed Development Plan

## Game Concept Overview

**Core Vision**: A multiplayer space exploration MMO where players traverse procedurally enhanced solar systems, discover fragments of an ancient "Knowledge Graph," and collaborate in real-time to piece together the mysteries of a lost civilization.

**Key Differentiators**:
- Each solar system is a persistent, real-time multiplayer room
- Dynamic knowledge discovery system that evolves the game world
- Seamless travel between systems with no loading screens
- Real-time physics and player interactions
- Emergent storytelling through collective discovery

---

## Detailed Technical Architecture

### 1. Frontend Architecture (`/src/client`)

#### Core Technologies
- **React 18+** with TypeScript for UI components
- **Babylon.js 6.0+** for 3D rendering and physics
- **Zustand** for client-side state management
- **React Query/TanStack Query** for server state caching
- **Socket.io-client** for WebSocket connections
- **Three-fiber** integration for React-Babylon hybrid components

#### Directory Structure
```
/src/client/
├── components/
│   ├── ui/                    # Reusable UI components
│   ├── game/                  # Game-specific components
│   │   ├── HUD.tsx
│   │   ├── ChatWindow.tsx
│   │   ├── GalaxyMap.tsx
│   │   └── KnowledgeGraph.tsx
│   └── babylon/               # Babylon.js React wrappers
├── scenes/                    # Babylon.js scene management
│   ├── SolarSystemScene.ts
│   ├── ShipController.ts
│   └── CameraManager.ts
├── stores/                    # Zustand stores
│   ├── gameStore.ts
│   ├── playerStore.ts
│   └── uiStore.ts
├── services/                  # API and WebSocket services
│   ├── api.ts
│   ├── websocket.ts
│   └── assetLoader.ts
├── types/                     # TypeScript definitions
└── utils/                     # Helper functions
```

#### Key Components Detail

**Babylon.js Scene Management**:
```typescript
// SolarSystemScene.ts
export class SolarSystemScene {
  private engine: Engine;
  private scene: Scene;
  private camera: UniversalCamera;
  private physicsPlugin: CannonJSPlugin;
  
  constructor(canvas: HTMLCanvasElement) {
    this.engine = new Engine(canvas, true);
    this.scene = new Scene(this.engine);
    this.setupPhysics();
    this.setupLighting();
    this.setupSkybox();
  }
  
  async loadSolarSystem(systemData: SolarSystemData) {
    // Load star, planets, asteroids, space stations
    await this.loadStar(systemData.star);
    await Promise.all(systemData.planets.map(p => this.loadPlanet(p)));
    await this.loadAsteroids(systemData.asteroids);
    this.setupOrbitalMechanics();
  }
}
```

**Real-time Player Synchronization**:
```typescript
// PlayerSyncManager.ts
export class PlayerSyncManager {
  private socket: Socket;
  private localPlayer: PlayerShip;
  private remotePlayers: Map<string, PlayerShip> = new Map();
  
  constructor(roomId: string) {
    this.socket = io(`wss://party.${PARTY_HOST}/${roomId}`);
    this.setupEventHandlers();
  }
  
  private setupEventHandlers() {
    this.socket.on('player-update', this.handlePlayerUpdate.bind(this));
    this.socket.on('player-joined', this.handlePlayerJoined.bind(this));
    this.socket.on('player-left', this.handlePlayerLeft.bind(this));
  }
  
  sendPlayerUpdate() {
    const update = {
      position: this.localPlayer.position,
      rotation: this.localPlayer.rotation,
      velocity: this.localPlayer.velocity,
      action: this.localPlayer.currentAction,
      timestamp: Date.now()
    };
    this.socket.emit('player-update', update);
  }
}
```

#### UI Component Architecture

**Game HUD System**:
```typescript
// HUD.tsx
export const GameHUD: React.FC = () => {
  const { player, currentSystem } = useGameStore();
  const { isMapOpen, isChatOpen } = useUIStore();
  
  return (
    <div className="fixed inset-0 pointer-events-none">
      <TopBar player={player} system={currentSystem} />
      <BottomBar />
      <MiniMap />
      {isMapOpen && <GalaxyMap />}
      {isChatOpen && <ChatWindow />}
      <ActionWheel />
    </div>
  );
};
```

### 2. Real-time Server Architecture (`/src/server/party`)

#### PartyKit Server Structure
```typescript
// src/server/party/solarSystem.ts
export default class SolarSystemServer implements PartyKitServer {
  constructor(readonly party: PartyKitRoom) {}
  
  private gameState: SolarSystemState = {
    players: new Map(),
    npcs: new Map(),
    events: [],
    resources: new Map(),
    discoveries: []
  };
  
  async onConnect(conn: PartyKitConnection, ctx: PartyKitContext) {
    const playerId = await this.authenticatePlayer(ctx);
    await this.loadPlayerData(playerId);
    this.addPlayerToSystem(playerId, conn);
    this.broadcastPlayerJoined(playerId);
  }
  
  async onMessage(message: string, sender: PartyKitConnection) {
    const data = JSON.parse(message);
    
    switch (data.type) {
      case 'player-update':
        this.handlePlayerUpdate(data, sender);
        break;
      case 'scan-planet':
        await this.handlePlanetScan(data, sender);
        break;
      case 'fire-weapon':
        this.handleWeaponFire(data, sender);
        break;
      case 'collect-resource':
        await this.handleResourceCollection(data, sender);
        break;
    }
  }
  
  private handlePlayerUpdate(data: PlayerUpdateData, sender: PartyKitConnection) {
    const playerId = this.getPlayerIdFromConnection(sender);
    
    // Validate movement (anti-cheat)
    if (!this.validateMovement(playerId, data)) return;
    
    // Update player state
    this.gameState.players.set(playerId, {
      ...this.gameState.players.get(playerId),
      position: data.position,
      rotation: data.rotation,
      velocity: data.velocity,
      lastUpdate: Date.now()
    });
    
    // Broadcast to other players
    this.party.broadcast(JSON.stringify({
      type: 'player-moved',
      playerId,
      ...data
    }), [sender.id]);
  }
  
  private async handlePlanetScan(data: ScanData, sender: PartyKitConnection) {
    const playerId = this.getPlayerIdFromConnection(sender);
    const player = this.gameState.players.get(playerId);
    
    // Check if player is in range
    if (!this.isInScanRange(player.position, data.planetId)) return;
    
    // Fetch planet data from D1
    const planetData = await this.fetchPlanetData(data.planetId);
    
    // Check for discoveries
    const discoveries = await this.processDiscoveries(playerId, planetData);
    
    // Send results back to player
    sender.send(JSON.stringify({
      type: 'scan-result',
      planetData,
      discoveries
    }));
    
    // Broadcast discoveries to all players
    if (discoveries.length > 0) {
      this.party.broadcast(JSON.stringify({
        type: 'discovery-made',
        playerId,
        discoveries
      }));
    }
  }
}
```

#### Game State Management
```typescript
// GameState.ts
export interface SolarSystemState {
  id: string;
  players: Map<string, PlayerState>;
  npcs: Map<string, NPCState>;
  events: GameEvent[];
  resources: Map<string, ResourceNode>;
  discoveries: Discovery[];
  lastTick: number;
}

export interface PlayerState {
  id: string;
  name: string;
  position: Vector3;
  rotation: Quaternion;
  velocity: Vector3;
  health: number;
  energy: number;
  currentAction?: PlayerAction;
  ship: ShipConfiguration;
  lastUpdate: number;
}
```

#### Anti-cheat & Validation
```typescript
// ValidationSystem.ts
export class ValidationSystem {
  private playerHistory: Map<string, PlayerMovementHistory> = new Map();
  
  validateMovement(playerId: string, newState: PlayerUpdateData): boolean {
    const history = this.playerHistory.get(playerId);
    if (!history) return true; // First update
    
    const timeDelta = newState.timestamp - history.lastTimestamp;
    const maxDistance = this.calculateMaxDistance(history.lastVelocity, timeDelta);
    const actualDistance = Vector3.Distance(history.lastPosition, newState.position);
    
    // Allow some tolerance for network latency
    return actualDistance <= maxDistance * 1.2;
  }
  
  private calculateMaxDistance(velocity: Vector3, timeDelta: number): number {
    return velocity.length() * (timeDelta / 1000) + MAX_ACCELERATION * Math.pow(timeDelta / 1000, 2);
  }
}
```

### 3. Backend API Architecture (`/src/server/api`)

#### API Structure with Hono
```typescript
// src/server/api/index.ts
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { jwt } from 'hono/jwt';

const app = new Hono();

app.use('*', cors());
app.use('/api/protected/*', jwt({ secret: ENV.JWT_SECRET }));

// Authentication routes
app.route('/api/auth', authRoutes);

// Game data routes
app.route('/api/player', playerRoutes);
app.route('/api/system', systemRoutes);
app.route('/api/knowledge', knowledgeRoutes);
app.route('/api/assets', assetRoutes);

export default app;
```

#### Authentication System
```typescript
// authRoutes.ts
export const authRoutes = new Hono()
  .post('/register', async (c) => {
    const { username, email, password } = await c.req.json();
    
    // Validate input
    const validation = validateRegistration({ username, email, password });
    if (!validation.valid) {
      return c.json({ error: validation.errors }, 400);
    }
    
    // Check if user exists
    const existingUser = await c.env.DB.prepare(
      'SELECT id FROM players WHERE email = ? OR username = ?'
    ).bind(email, username).first();
    
    if (existingUser) {
      return c.json({ error: 'User already exists' }, 409);
    }
    
    // Hash password and create user
    const hashedPassword = await hashPassword(password);
    const playerId = generateUUID();
    
    await c.env.DB.prepare(`
      INSERT INTO players (id, username, email, password_hash, created_at)
      VALUES (?, ?, ?, ?, ?)
    `).bind(playerId, username, email, hashedPassword, new Date().toISOString()).run();
    
    // Create default ship
    await createDefaultShip(c.env.DB, playerId);
    
    // Generate JWT
    const token = await generateJWT(playerId, c.env.JWT_SECRET);
    
    return c.json({ token, playerId });
  })
  .post('/login', async (c) => {
    const { email, password } = await c.req.json();
    
    // Find user
    const user = await c.env.DB.prepare(
      'SELECT id, password_hash FROM players WHERE email = ?'
    ).bind(email).first();
    
    if (!user || !await verifyPassword(password, user.password_hash)) {
      return c.json({ error: 'Invalid credentials' }, 401);
    }
    
    // Generate JWT
    const token = await generateJWT(user.id, c.env.JWT_SECRET);
    
    return c.json({ token, playerId: user.id });
  });
```

#### Player Data API
```typescript
// playerRoutes.ts
export const playerRoutes = new Hono()
  .get('/:id', async (c) => {
    const playerId = c.req.param('id');
    
    const player = await c.env.DB.prepare(`
      SELECT p.*, s.* FROM players p
      LEFT JOIN ships s ON p.current_ship_id = s.id
      WHERE p.id = ?
    `).bind(playerId).first();
    
    if (!player) {
      return c.json({ error: 'Player not found' }, 404);
    }
    
    return c.json(player);
  })
  .put('/:id/location', async (c) => {
    const playerId = c.req.param('id');
    const { systemId, position } = await c.req.json();
    
    await c.env.DB.prepare(`
      UPDATE players SET current_system_id = ?, last_position = ?
      WHERE id = ?
    `).bind(systemId, JSON.stringify(position), playerId).run();
    
    return c.json({ success: true });
  })
  .get('/:id/inventory', async (c) => {
    const playerId = c.req.param('id');
    
    const inventory = await c.env.DB.prepare(`
      SELECT i.*, it.name, it.description, it.rarity
      FROM inventory i
      JOIN item_types it ON i.item_type_id = it.id
      WHERE i.player_id = ?
    `).bind(playerId).all();
    
    return c.json(inventory.results);
  });
```

#### Solar System Generation API
```typescript
// systemRoutes.ts
export const systemRoutes = new Hono()
  .get('/:id', async (c) => {
    const systemId = c.req.param('id');
    
    // Get system from cache first
    const cached = await c.env.KV.get(`system:${systemId}`);
    if (cached) {
      return c.json(JSON.parse(cached));
    }
    
    // Generate or fetch from database
    const system = await generateSolarSystem(systemId, c.env.DB);
    
    // Cache for 1 hour
    await c.env.KV.put(`system:${systemId}`, JSON.stringify(system), {
      expirationTtl: 3600
    });
    
    return c.json(system);
  })
  .get('/', async (c) => {
    // Get galaxy map - all discovered systems
    const systems = await c.env.DB.prepare(`
      SELECT id, name, star_type, planet_count, discovery_level
      FROM solar_systems
      WHERE discovery_level > 0
      ORDER BY discovery_level DESC
    `).all();
    
    return c.json(systems.results);
  });

async function generateSolarSystem(systemId: string, db: D1Database): Promise<SolarSystemData> {
  // Check if system exists in database
  let system = await db.prepare('SELECT * FROM solar_systems WHERE id = ?').bind(systemId).first();
  
  if (!system) {
    // Procedurally generate new system
    const generator = new SystemGenerator(systemId);
    system = generator.generate();
    
    // Save to database
    await db.prepare(`
      INSERT INTO solar_systems (id, name, star_type, star_mass, planet_count, seed, generated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).bind(
      system.id,
      system.name,
      system.star.type,
      system.star.mass,
      system.planets.length,
      system.seed,
      new Date().toISOString()
    ).run();
    
    // Save planets
    for (const planet of system.planets) {
      await savePlanetToDatabase(db, planet, systemId);
    }
  }
  
  return system;
}
```

### 4. Database Schema (Cloudflare D1)

#### Core Tables
```sql
-- Players table
CREATE TABLE players (
  id TEXT PRIMARY KEY,
  username TEXT UNIQUE NOT NULL,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  current_system_id TEXT,
  current_ship_id TEXT,
  last_position TEXT, -- JSON encoded Vector3
  credits INTEGER DEFAULT 1000,
  experience_points INTEGER DEFAULT 0,
  reputation INTEGER DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  last_login DATETIME,
  FOREIGN KEY (current_system_id) REFERENCES solar_systems(id),
  FOREIGN KEY (current_ship_id) REFERENCES ships(id)
);

-- Solar Systems table
CREATE TABLE solar_systems (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  star_type TEXT NOT NULL, -- O, B, A, F, G, K, M
  star_mass REAL NOT NULL,
  star_temperature INTEGER NOT NULL,
  planet_count INTEGER NOT NULL,
  seed TEXT NOT NULL, -- For procedural generation consistency
  discovery_level INTEGER DEFAULT 0, -- 0 = undiscovered, 100 = fully mapped
  first_discovered_by TEXT,
  generated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (first_discovered_by) REFERENCES players(id)
);

-- Planets table
CREATE TABLE planets (
  id TEXT PRIMARY KEY,
  system_id TEXT NOT NULL,
  name TEXT NOT NULL,
  type TEXT NOT NULL, -- terrestrial, gas_giant, ice_giant, dwarf
  mass REAL NOT NULL,
  radius REAL NOT NULL,
  orbital_distance REAL NOT NULL, -- AU from star
  orbital_period REAL NOT NULL, -- Earth days
  atmosphere TEXT, -- JSON description
  surface_composition TEXT, -- JSON description
  temperature_range TEXT, -- JSON: {min, max, average}
  has_life BOOLEAN DEFAULT FALSE,
  resource_richness INTEGER DEFAULT 0, -- 0-100
  exploration_level INTEGER DEFAULT 0, -- 0-100
  discovered_at DATETIME,
  discovered_by TEXT,
  FOREIGN KEY (system_id) REFERENCES solar_systems(id),
  FOREIGN KEY (discovered_by) REFERENCES players(id)
);

-- Ships table
CREATE TABLE ships (
  id TEXT PRIMARY KEY,
  owner_id TEXT NOT NULL,
  name TEXT NOT NULL,
  ship_class TEXT NOT NULL, -- explorer, fighter, trader, mining
  hull_points INTEGER NOT NULL,
  max_hull_points INTEGER NOT NULL,
  shield_points INTEGER DEFAULT 0,
  max_shield_points INTEGER DEFAULT 0,
  energy_capacity INTEGER NOT NULL,
  cargo_capacity INTEGER NOT NULL,
  speed_multiplier REAL DEFAULT 1.0,
  jump_range INTEGER DEFAULT 1, -- number of systems can jump
  equipment TEXT, -- JSON array of equipped items
  modifications TEXT, -- JSON array of ship mods
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (owner_id) REFERENCES players(id)
);

-- Knowledge Graph table
CREATE TABLE knowledge_fragments (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL, -- technology, history, coordinates, blueprint
  title TEXT NOT NULL,
  content TEXT NOT NULL, -- The actual knowledge/data
  rarity TEXT NOT NULL, -- common, uncommon, rare, legendary, artifact
  prerequisites TEXT, -- JSON array of required fragment IDs
  unlocks TEXT, -- JSON array of fragment IDs this unlocks
  discovery_method TEXT NOT NULL, -- planet_scan, artifact_analysis, etc.
  discovered_by TEXT NOT NULL,
  discovered_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  discovery_location TEXT, -- system_id:planet_id or coordinates
  verified_by TEXT, -- JSON array of player IDs who verified this
  FOREIGN KEY (discovered_by) REFERENCES players(id)
);

-- Inventory system
CREATE TABLE item_types (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL, -- resource, equipment, consumable, key_item
  rarity TEXT NOT NULL,
  base_value INTEGER DEFAULT 0,
  stackable BOOLEAN DEFAULT TRUE,
  max_stack_size INTEGER DEFAULT 100
);

CREATE TABLE inventory (
  id TEXT PRIMARY KEY,
  player_id TEXT NOT NULL,
  item_type_id TEXT NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 1,
  condition_percentage INTEGER DEFAULT 100, -- for equipment durability
  enchantments TEXT, -- JSON for special properties
  acquired_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (player_id) REFERENCES players(id),
  FOREIGN KEY (item_type_id) REFERENCES item_types(id)
);

-- Resource nodes in systems
CREATE TABLE resource_nodes (
  id TEXT PRIMARY KEY,
  system_id TEXT NOT NULL,
  planet_id TEXT,
  position TEXT NOT NULL, -- JSON Vector3
  resource_type TEXT NOT NULL,
  quantity_remaining INTEGER NOT NULL,
  max_quantity INTEGER NOT NULL,
  regeneration_rate REAL DEFAULT 0, -- per hour
  difficulty INTEGER DEFAULT 1, -- mining/extraction difficulty
  last_harvested DATETIME,
  discovered_by TEXT,
  FOREIGN KEY (system_id) REFERENCES solar_systems(id),
  FOREIGN KEY (planet_id) REFERENCES planets(id),
  FOREIGN KEY (discovered_by) REFERENCES players(id)
);

-- Player achievements and statistics
CREATE TABLE player_achievements (
  id TEXT PRIMARY KEY,
  player_id TEXT NOT NULL,
  achievement_type TEXT NOT NULL,
  achievement_data TEXT, -- JSON with specific achievement data
  earned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (player_id) REFERENCES players(id)
);

-- System for tracking player interactions
CREATE TABLE player_interactions (
  id TEXT PRIMARY KEY,
  initiator_id TEXT NOT NULL,
  target_id TEXT NOT NULL,
  interaction_type TEXT NOT NULL, -- trade, combat, assistance, etc.
  data TEXT, -- JSON with interaction details
  occurred_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  system_id TEXT,
  FOREIGN KEY (initiator_id) REFERENCES players(id),
  FOREIGN KEY (target_id) REFERENCES players(id),
  FOREIGN KEY (system_id) REFERENCES solar_systems(id)
);
```

#### Database Indexes for Performance
```sql
-- Player lookup indexes
CREATE INDEX idx_players_username ON players(username);
CREATE INDEX idx_players_email ON players(email);
CREATE INDEX idx_players_current_system ON players(current_system_id);

-- System and planet indexes
CREATE INDEX idx_planets_system ON planets(system_id);
CREATE INDEX idx_planets_discovered_by ON planets(discovered_by);
CREATE INDEX idx_systems_discovery_level ON solar_systems(discovery_level);

-- Knowledge graph indexes
CREATE INDEX idx_knowledge_type ON knowledge_fragments(type);
CREATE INDEX idx_knowledge_rarity ON knowledge_fragments(rarity);
CREATE INDEX idx_knowledge_discovered_by ON knowledge_fragments(discovered_by);

-- Inventory indexes
CREATE INDEX idx_inventory_player ON inventory(player_id);
CREATE INDEX idx_inventory_item_type ON inventory(item_type_id);

-- Resource node indexes
CREATE INDEX idx_resources_system ON resource_nodes(system_id);
CREATE INDEX idx_resources_type ON resource_nodes(resource_type);
```

### 5. Asset Management (Cloudflare R2)

#### Asset Organization Structure
```
/game-assets/
├── models/
│   ├── ships/
│   │   ├── explorer-class-01.glb
│   │   ├── fighter-class-01.glb
│   │   └── trader-class-01.glb
│   ├── planets/
│   │   ├── terrestrial/
│   │   ├── gas-giant/
│   │   └── ice-world/
│   ├── stations/
│   └── environment/
├── textures/
│   ├── skyboxes/
│   ├── planet-surfaces/
│   └── ui/
├── audio/
│   ├── music/
│   ├── sfx/
│   └── voice/
└── data/
    ├── star-catalogs/
    └── procedural-configs/
```

#### Asset Loading System
```typescript
// AssetManager.ts
export class AssetManager {
  private cache: Map<string, any> = new Map();
  private loadingPromises: Map<string, Promise<any>> = new Map();
  
  async loadAsset<T>(assetPath: string, type: AssetType): Promise<T> {
    // Check cache first
    if (this.cache.has(assetPath)) {
      return this.cache.get(assetPath);
    }
    
    // Check if already loading
    if (this.loadingPromises.has(assetPath)) {
      return this.loadingPromises.get(assetPath);
    }
    
    // Start loading
    const loadPromise = this.doLoadAsset<T>(assetPath, type);
    this.loadingPromises.set(assetPath, loadPromise);
    
    try {
      const asset = await loadPromise;
      this.cache.set(assetPath, asset);
      return asset;
    } finally {
      this.loadingPromises.delete(assetPath);
    }
  }
  
  private async doLoadAsset<T>(assetPath: string, type: AssetType): Promise<T> {
    // Get signed URL from API
    const response = await fetch(`/api/assets/url?path=${encodeURIComponent(assetPath)}`);
    const { url } = await response.json();
    
    switch (type) {
      case AssetType.MODEL:
        return this.loadModel(url);
      case AssetType.TEXTURE:
        return this.loadTexture(url);
      case AssetType.AUDIO:
        return this.loadAudio(url);
      default:
        throw new Error(`Unknown asset type: ${type}`);
    }
  }
  
  private async loadModel(url: string): Promise<AbstractMesh[]> {
    return new Promise((resolve, reject) => {
      SceneLoader.ImportMesh("", "", url, this.scene, (meshes) => {
        resolve(meshes);
      }, null, reject);
    });
  }
}
```

### 6. Procedural Generation System

#### Solar System Generator
```typescript
// SystemGenerator.ts
export class SystemGenerator {
  private rng: SeededRandom;
  
  constructor(private systemId: string) {
    this.rng = new SeededRandom(this.systemId);
  }
  
  generate(): SolarSystemData {
    const starData = this.generateStar();
    const planetCount = this.determinePlanetCount(starData);
    const planets = this.generatePlanets(starData, planetCount);
    const asteroids = this.generateAsteroids(starData, planets);
    const name = this.generateSystemName();
    
    return {
      id: this.systemId,
      name,
      star: starData,
      planets,
      asteroids,
      spaceStations: [],
      resources: this.generateResourceNodes(planets),
      seed: this.systemId
    };
  }
  
  private generateStar(): StarData {
    const stellarClass = this.rng.weightedChoice([
      { value: 'M', weight: 76.45 }, // Red dwarf
      { value: 'K', weight: 12.1 },  // Orange dwarf
      { value: 'G', weight: 7.6 },   // Yellow dwarf (like our Sun)
      { value: 'F', weight: 3.0 },   // Yellow-white
      { value: 'A', weight: 0.6 },   // White
      { value: 'B', weight: 0.13 },  // Blue-white
      { value: 'O', weight: 0.00003 } // Blue giant
    ]);
    
    const massRange = STELLAR_MASS_RANGES[stellarClass];
    const mass = this.rng.uniform(massRange.min, massRange.max);
    const temperature = this.calculateStellarTemperature(stellarClass, mass);
    const luminosity = this.calculateStellarLuminosity(mass, temperature);
    
    return {
      type: stellarClass,
      mass,
      temperature,
      luminosity,
      age: this.rng.uniform(0.1, 13.8), // billion years
      metallicity: this.rng.normal(0, 0.3) // relative to Sun
    };
  }
  
  private generatePlanets(star: StarData, count: number): PlanetData[] {
    const planets: PlanetData[] = [];
    const habitableZone = this.calculateHabitableZone(star);
    
    // Generate orbital distances using Titius-Bode-like law with randomization
    const orbitalDistances = this.generateOrbitalDistances(count, star);
    
    for (let i = 0; i < count; i++) {
      const distance = orbitalDistances[i];
      const planet = this.generatePlanet(star, distance, habitableZone, i);
      planets.push(planet);
    }
    
    return planets;
  }
  
  private generatePlanet(star: StarData, orbitalDistance: number, habitableZone: HabitableZone, index: number): PlanetData {
    const planetType = this.determinePlanetType(star, orbitalDistance, habitableZone);
    const mass = this.generatePlanetMass(planetType, orbitalDistance);
    const radius = this.calculatePlanetRadius(mass, planetType);
    
    const temperature = this.calculatePlanetTemperature(star, orbitalDistance, mass, radius);
    const atmosphere = this.generateAtmosphere(planetType, mass, temperature);
    const hasLife = this.determineLifePotential(planetType, temperature, atmosphere, habitableZone, orbitalDistance);
    
    return {
      id: `${this.systemId}-planet-${index}`,
      name: this.generatePlanetName(planetType, index),
      type: planetType,
      mass,
      radius,
      orbitalDistance,
      orbitalPeriod: this.calculateOrbitalPeriod(orbitalDistance, star.mass),
      rotationPeriod: this.generateRotationPeriod(),
      axialTilt: this.rng.uniform(0, 180),
      atmosphere,
      surfaceComposition: this.generateSurfaceComposition(planetType),
      temperature: {
        min: temperature.min,
        max: temperature.max,
        average: temperature.average
      },
      hasLife,
      biosphere: hasLife ? this.generateBiosphere() : null,
      resourceRichness: this.calculateResourceRichness(planetType, star.metallicity),
      moons: this.generateMoons(mass, planetType)
    };
  }
}
```

#### Knowledge Graph Generation
```typescript
// KnowledgeGenerator.ts
export class KnowledgeGenerator {
  private static readonly FRAGMENT_TYPES = [
    'stellar_cartography',
    'ancient_technology',
    'xenobiology',
    'archaeological_site',
    'navigation_beacon',
    'cultural_artifact',
    'energy_signature',
    'quantum_anomaly'
  ];
  
  private static readonly RARITY_WEIGHTS = {
    common: 0.5,
    uncommon: 0.3,
    rare: 0.15,
    legendary: 0.04,
    artifact: 0.01
  };
  
  static generateFragment(discoveryContext: DiscoveryContext): KnowledgeFragment {
    const rng = new SeededRandom(discoveryContext.locationId + discoveryContext.playerId + Date.now());
    
    const type = rng.choice(this.FRAGMENT_TYPES);
    const rarity = rng.weightedChoice(Object.entries(this.RARITY_WEIGHTS).map(([key, value]) => ({ value: key, weight: value })));
    
    const fragment = {
      id: generateUUID(),
      type,
      rarity,
      title: this.generateTitle(type, rarity, discoveryContext),
      content: this.generateContent(type, rarity, discoveryContext),
      prerequisites: this.determinePrerequisites(type, rarity),
      unlocks: this.determineUnlocks(type, rarity),
      discoveryMethod: discoveryContext.method,
      discoveredBy: discoveryContext.playerId,
      discoveredAt: new Date().toISOString(),
      discoveryLocation: discoveryContext.locationId,
      verificationRequired: rarity === 'legendary' || rarity === 'artifact',
      gameplayEffects: this.generateGameplayEffects(type, rarity)
    };
    
    return fragment;
  }
  
  private static generateContent(type: string, rarity: string, context: DiscoveryContext): string {
    const templates = KNOWLEDGE_TEMPLATES[type][rarity];
    const template = context.rng.choice(templates);
    
    return this.interpolateTemplate(template, context);
  }
  
  private static generateGameplayEffects(type: string, rarity: string): GameplayEffect[] {
    const effects: GameplayEffect[] = [];
    
    switch (type) {
      case 'ancient_technology':
        if (rarity === 'rare' || rarity === 'legendary') {
          effects.push({
            type: 'unlock_blueprint',
            data: { blueprintType: 'ship_component', tier: rarity }
          });
        }
        break;
      case 'stellar_cartography':
        effects.push({
          type: 'reveal_system',
          data: { systemCount: rarity === 'legendary' ? 5 : rarity === 'rare' ? 3 : 1 }
        });
        break;
      case 'navigation_beacon':
        effects.push({
          type: 'fast_travel_unlock',
          data: { destinationType: 'discovered_systems' }
        });
        break;
    }
    
    return effects;
  }
}

// Knowledge templates for procedural generation
const KNOWLEDGE_TEMPLATES = {
  stellar_cartography: {
    common: [
      "Navigation data indicates a {star_type} star system at coordinates {coordinates}. Preliminary scans suggest {planet_count} planetary bodies.",
      "Ancient star charts reference the {system_name} system, noting unusual {astronomical_feature}."
    ],
    rare: [
      "Detailed stellar cartography reveals a hidden cluster of {cluster_size} systems beyond the {nebula_name} Nebula. These systems show signs of {ancient_civilization} activity.",
      "Quantum navigation matrix contains coordinates to the lost {legendary_system_name} system, rumored to contain artifacts of the {civilization_name}."
    ],
    legendary: [
      "The Celestial Codex fragment reveals the location of {artifact_system_name}, the legendary forge-world where the {civilization_name} created their most powerful technologies."
    ]
  },
  ancient_technology: {
    common: [
      "Technical specifications for {device_name}: a {civilization_name} tool used for {function}. Basic principles suggest {technology_type} applications.",
    ],
    rare: [
      "Blueprint data for {advanced_device}: Advanced {civilization_name} technology capable of {advanced_function}. Requires {rare_material} to construct."
    ],
    legendary: [
      "Complete schematics for the {legendary_device}: A reality-altering artifact that can {reality_effect}. Construction requires fragments from {number} other legendary discoveries."
    ]
  }
};
```

### 7. Advanced Game Systems

#### Physics and Movement System
```typescript
// PhysicsManager.ts
export class PhysicsManager {
  private world: CANNON.World;
  private shipControllers: Map<string, ShipPhysicsController> = new Map();
  
  constructor(scene: Scene) {
    this.world = new CANNON.World();
    this.world.gravity.set(0, 0, 0); // Space has no gravity by default
    this.world.broadphase = new CANNON.NaiveBroadphase();
    this.world.solver.iterations = 10;
    
    this.setupCollisionGroups();
  }
  
  private setupCollisionGroups() {
    // Define collision groups for different object types
    this.SHIP_GROUP = 1;
    this.PLANET_GROUP = 2;
    this.ASTEROID_GROUP = 4;
    this.PROJECTILE_GROUP = 8;
    this.STATION_GROUP = 16;
  }
  
  addShip(shipId: string, position: Vector3, mesh: AbstractMesh): ShipPhysicsController {
    const shape = new CANNON.Sphere(2); // 2 unit radius
    const body = new CANNON.Body({ mass: 1000 });
    body.addShape(shape);
    body.position.set(position.x, position.y, position.z);
    body.collisionFilterGroup = this.SHIP_GROUP;
    body.collisionFilterMask = this.PLANET_GROUP | this.ASTEROID_GROUP | this.STATION_GROUP;
    
    this.world.add(body);
    
    const controller = new ShipPhysicsController(body, mesh);
    this.shipControllers.set(shipId, controller);
    
    return controller;
  }
  
  addPlanet(planet: PlanetData): void {
    const radius = planet.radius * SCALE_FACTOR;
    const shape = new CANNON.Sphere(radius);
    const body = new CANNON.Body({ mass: 0 }); // Static body
    body.addShape(shape);
    body.position.set(
      planet.orbitalDistance * AU_TO_UNITS * Math.cos(planet.currentOrbitalAngle),
      0,
      planet.orbitalDistance * AU_TO_UNITS * Math.sin(planet.currentOrbitalAngle)
    );
    body.collisionFilterGroup = this.PLANET_GROUP;
    
    this.world.add(body);
    
    // Add gravitational field
    this.addGravitationalField(planet, body);
  }
  
  private addGravitationalField(planet: PlanetData, body: CANNON.Body): void {
    const gravitationalRadius = planet.radius * SCALE_FACTOR * 5; // Gravity extends 5x planet radius
    const gravitationalStrength = planet.mass * GRAVITATIONAL_CONSTANT;
    
    // Custom force application for ships within gravitational field
    this.world.addEventListener('preStep', () => {
      this.shipControllers.forEach((controller) => {
        const distance = controller.body.position.distanceTo(body.position);
        if (distance < gravitationalRadius) {
          const force = this.calculateGravitationalForce(
            controller.body.position,
            body.position,
            controller.body.mass,
            gravitationalStrength,
            distance
          );
          controller.body.force.x += force.x;
          controller.body.force.y += force.y;
          controller.body.force.z += force.z;
        }
      });
    });
  }
  
  step(deltaTime: number): void {
    this.world.step(deltaTime);
    
    // Update visual meshes to match physics bodies
    this.shipControllers.forEach((controller) => {
      controller.updateMeshFromPhysics();
    });
  }
}

// Ship-specific physics controller
export class ShipPhysicsController {
  private thrusterForce = 50000;
  private rotationTorque = 10000;
  private maxSpeed = 100;
  private dampingFactor = 0.98;
  
  constructor(public body: CANNON.Body, private mesh: AbstractMesh) {
    body.material = new CANNON.Material("ship");
    body.material.friction = 0.1;
    body.material.restitution = 0.3;
    body.linearDamping = 0.01;
    body.angularDamping = 0.05;
  }
  
  applyThrust(direction: Vector3, intensity: number): void {
    const force = direction.clone().normalize().scale(this.thrusterForce * intensity);
    this.body.force.x += force.x;
    this.body.force.y += force.y;
    this.body.force.z += force.z;
    
    // Apply speed limiting
    const currentSpeed = this.body.velocity.length();
    if (currentSpeed > this.maxSpeed) {
      this.body.velocity.scale(this.maxSpeed / currentSpeed);
    }
  }
  
  applyRotation(axis: Vector3, intensity: number): void {
    const torque = axis.clone().normalize().scale(this.rotationTorque * intensity);
    this.body.torque.x += torque.x;
    this.body.torque.y += torque.y;
    this.body.torque.z += torque.z;
  }
  
  updateMeshFromPhysics(): void {
    this.mesh.position.copyFrom(this.body.position);
    this.mesh.rotationQuaternion = new Quaternion(
      this.body.quaternion.x,
      this.body.quaternion.y,
      this.body.quaternion.z,
      this.body.quaternion.w
    );
  }
}
```

#### Combat System
```typescript
// CombatSystem.ts
export class CombatSystem {
  private projectiles: Map<string, Projectile> = new Map();
  private weaponCooldowns: Map<string, number> = new Map();
  
  constructor(private scene: Scene, private physicsManager: PhysicsManager) {}
  
  fireWeapon(shipId: string, weaponType: WeaponType, origin: Vector3, direction: Vector3): boolean {
    const cooldownKey = `${shipId}-${weaponType}`;
    const now = Date.now();
    
    // Check cooldown
    if (this.weaponCooldowns.has(cooldownKey) && 
        this.weaponCooldowns.get(cooldownKey)! > now) {
      return false;
    }
    
    const weapon = WEAPON_CONFIGS[weaponType];
    const projectileId = generateUUID();
    
    // Create projectile
    const projectile = new Projectile({
      id: projectileId,
      ownerId: shipId,
      type: weaponType,
      position: origin.clone(),
      velocity: direction.clone().normalize().scale(weapon.projectileSpeed),
      damage: weapon.damage,
      range: weapon.range,
      lifetime: weapon.range / weapon.projectileSpeed * 1000, // ms
      createdAt: now
    });
    
    this.projectiles.set(projectileId, projectile);
    this.createProjectileVisual(projectile);
    
    // Set cooldown
    this.weaponCooldowns.set(cooldownKey, now + weapon.cooldown);
    
    return true;
  }
  
  update(deltaTime: number): CombatEvent[] {
    const events: CombatEvent[] = [];
    const now = Date.now();
    
    this.projectiles.forEach((projectile, id) => {
      // Update projectile position
      projectile.position.addInPlace(
        projectile.velocity.clone().scale(deltaTime / 1000)
      );
      
      // Check for hits
      const hitResult = this.checkProjectileHits(projectile);
      if (hitResult) {
        events.push({
          type: 'projectile_hit',
          projectileId: id,
          targetId: hitResult.targetId,
          damage: projectile.damage,
          position: projectile.position.clone()
        });
        this.destroyProjectile(id);
        return;
      }
      
      // Check lifetime
      if (now - projectile.createdAt > projectile.lifetime) {
        this.destroyProjectile(id);
        return;
      }
      
      // Update visual
      this.updateProjectileVisual(projectile);
    });
    
    return events;
  }
  
  private checkProjectileHits(projectile: Projectile): HitResult | null {
    // Check collision with ships
    const ships = this.scene.getTransformNodesByTags("ship");
    for (const ship of ships) {
      if (ship.id === projectile.ownerId) continue; // Don't hit self
      
      const distance = Vector3.Distance(projectile.position, ship.getAbsolutePosition());
      if (distance < SHIP_COLLISION_RADIUS) {
        return { targetId: ship.id, targetType: 'ship' };
      }
    }
    
    // Check collision with planets/asteroids
    const planets = this.scene.getTransformNodesByTags("planet");
    for (const planet of planets) {
      const planetData = planet.metadata.planetData as PlanetData;
      const distance = Vector3.Distance(projectile.position, planet.getAbsolutePosition());
      if (distance < planetData.radius * SCALE_FACTOR) {
        return { targetId: planet.id, targetType: 'planet' };
      }
    }
    
    return null;
  }
}

// Weapon configuration
const WEAPON_CONFIGS: Record<WeaponType, WeaponConfig> = {
  laser_cannon: {
    damage: 25,
    range: 1000,
    projectileSpeed: 500,
    cooldown: 500, // ms
    energyCost: 10,
    projectileType: 'energy'
  },
  plasma_torpedo: {
    damage: 75,
    range: 2000,
    projectileSpeed: 200,
    cooldown: 2000,
    energyCost: 50,
    projectileType: 'explosive'
  },
  railgun: {
    damage: 150,
    range: 3000,
    projectileSpeed: 1000,
    cooldown: 5000,
    energyCost: 100,
    projectileType: 'kinetic'
  }
};
```

#### Economy and Trading System
```typescript
// EconomySystem.ts
export class EconomySystem {
  private marketData: Map<string, MarketData> = new Map();
  private priceHistory: Map<string, PriceHistory[]> = new Map();
  
  constructor(private db: D1Database) {}
  
  async initializeMarkets(): Promise<void> {
    // Load existing market data
    const markets = await this.db.prepare(`
      SELECT * FROM markets WHERE active = 1
    `).all();
    
    for (const market of markets.results) {
      this.marketData.set(market.id, market as MarketData);
    }
    
    // Start market simulation
    this.startMarketSimulation();
  }
  
  private startMarketSimulation(): void {
    setInterval(() => {
      this.updateMarketPrices();
    }, 60000); // Update every minute
  }
  
  private updateMarketPrices(): void {
    this.marketData.forEach((market, marketId) => {
      market.commodities.forEach((commodity, commodityId) => {
        const oldPrice = commodity.currentPrice;
        const newPrice = this.calculateNewPrice(market, commodity);
        
        // Update price
        commodity.currentPrice = newPrice;
        commodity.priceChange = ((newPrice - oldPrice) / oldPrice) * 100;
        commodity.lastUpdated = Date.now();
        
        // Record price history
        this.recordPriceHistory(marketId, commodityId, newPrice);
        
        // Update supply/demand based on player activity
        this.adjustSupplyDemand(market, commodity);
      });
    });
  }
  
  private calculateNewPrice(market: MarketData, commodity: CommodityData): number {
    const basePrice = commodity.basePrice;
    const supplyDemandRatio = commodity.supply / commodity.demand;
    
    // Market forces
    const marketMultiplier = Math.max(0.1, Math.min(10, 1 / supplyDemandRatio));
    
    // Random market volatility
    const volatility = commodity.volatility || 0.05;
    const randomChange = (Math.random() - 0.5) * volatility;
    
    // Economic events (wars, discoveries, etc.)
    const eventMultiplier = this.getEventMultiplier(market, commodity);
    
    let newPrice = basePrice * marketMultiplier * (1 + randomChange) * eventMultiplier;
    
    // Ensure price doesn't go below minimum or above maximum
    newPrice = Math.max(commodity.minPrice || basePrice * 0.1, newPrice);
    newPrice = Math.min(commodity.maxPrice || basePrice * 10, newPrice);
    
    return Math.round(newPrice * 100) / 100; // Round to 2 decimal places
  }
  
  async executeTrade(trade: TradeOrder): Promise<TradeResult> {
    const market = this.marketData.get(trade.marketId);
    if (!market) {
      return { success: false, error: 'Market not found' };
    }
    
    const commodity = market.commodities.get(trade.commodityId);
    if (!commodity) {
      return { success: false, error: 'Commodity not found' };
    }
    
    // Validate trade
    const validation = await this.validateTrade(trade, market, commodity);
    if (!validation.valid) {
      return { success: false, error: validation.error };
    }
    
    const totalCost = trade.quantity * commodity.currentPrice;
    
    try {
      // Execute trade in database transaction
      await this.db.batch([
        this.db.prepare(`
          UPDATE players SET credits = credits - ? WHERE id = ?
        `).bind(totalCost, trade.playerId),
        
        this.db.prepare(`
          INSERT INTO inventory (id, player_id, item_type_id, quantity, acquired_at)
          VALUES (?, ?, ?, ?, ?)
          ON CONFLICT(player_id, item_type_id) DO UPDATE SET
          quantity = quantity + ?
        `).bind(generateUUID(), trade.playerId, trade.commodityId, trade.quantity, new Date().toISOString(), trade.quantity),
        
        this.db.prepare(`
          INSERT INTO trade_history (id, player_id, market_id, commodity_id, quantity, price, trade_type, executed_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(generateUUID(), trade.playerId, trade.marketId, trade.commodityId, trade.quantity, commodity.currentPrice, 'buy', new Date().toISOString())
      ]);
      
      // Update market supply/demand
      commodity.supply -= trade.quantity;
      commodity.demand += trade.quantity * 0.1; // Increased interest
      
      return {
        success: true,
        totalCost,
        newPrice: commodity.currentPrice,
        transactionId: generateUUID()
      };
      
    } catch (error) {
      return { success: false, error: 'Transaction failed' };
    }
  }
  
  getMarketData(marketId: string): MarketData | null {
    return this.marketData.get(marketId) || null;
  }
  
  getPriceHistory(marketId: string, commodityId: string, days: number = 30): PriceHistory[] {
    const key = `${marketId}-${commodityId}`;
    const history = this.priceHistory.get(key) || [];
    const cutoff = Date.now() - (days * 24 * 60 * 60 * 1000);
    
    return history.filter(h => h.timestamp > cutoff);
  }
}
```

### 8. Detailed Implementation Phases

#### Phase 1: Foundation & Core Multiplayer (Weeks 1-4)

**Week 1: Project Setup**
```bash
# Initialize monorepo structure
npm create cloudflare@latest chronicles-synergistic-sphere
cd chronicles-synergistic-sphere

# Setup workspace structure
mkdir -p src/{client,server/{party,api}}
mkdir -p public/{models,textures,audio}

# Install dependencies
npm install react @types/react babylon.js @babylonjs/core @babylonjs/loaders
npm install partykit hono @cloudflare/workers-types
npm install zustand @tanstack/react-query socket.io-client
```

**Week 2: Basic Client Setup**
- Initialize React application with TypeScript
- Setup Babylon.js canvas and basic scene
- Create simple ship model and basic movement controls
- Implement camera system (third-person follow camera)
- Basic UI components (HUD, menu system)

**Week 3: PartyKit Integration**
- Create basic PartyServer for single solar system
- Implement WebSocket connection from client
- Sync basic player positions between clients
- Handle player join/leave events
- Basic anti-cheat validation for movement

**Week 4: Initial Deployment**
- Setup Cloudflare Workers deployment
- Configure PartyKit hosting
- Deploy initial client to Cloudflare Pages
- Establish CI/CD pipeline with GitHub Actions
- Basic monitoring and error tracking

#### Phase 2: World Persistence & Data (Weeks 5-8)

**Week 5: Database Schema**
- Design and create D1 database tables
- Setup database migrations system
- Create seed data for initial solar systems
- Implement basic ORM/query helpers

**Week 6: API Development**
- Build Hono-based API workers
- Implement solar system data endpoints
- Create player management APIs
- Asset URL generation for R2 storage

**Week 7: Dynamic World Loading**
- Integrate API calls into client
- Dynamic Babylon.js scene generation from API data
- Asset loading and caching system
- Performance optimization for large scenes

**Week 8: Asset Pipeline**
- Setup R2 bucket and upload initial assets
- Implement asset versioning and CDN
- Create 3D model optimization pipeline
- Audio asset management

#### Phase 3: Core Gameplay Loop (Weeks 9-14)

**Week 9-10: Authentication System**
- Implement JWT-based authentication
- User registration and login flows
- Session management and persistence
- Security hardening

**Week 11-12: Galaxy Navigation**
- Galaxy map UI component
- Solar system discovery mechanics
- Travel between systems (room switching)
- Bookmark and waypoint system

**Week 13-14: Basic Interactions**
- Planet scanning mechanics
- Resource collection system
- Basic inventory management
- Simple crafting system

#### Phase 4: Advanced Features & Polish (Weeks 15-20)

**Week 15-16: Knowledge Graph System**
- Fragment discovery mechanics
- Knowledge storage and visualization
- Fragment verification system
- Collaborative discovery features

**Week 17-18: NPCs and AI**
- Basic AI ship behaviors
- NPC interaction system
- Dynamic event generation
- Faction reputation system

**Week 19-20: Economy and Trading**
- Market simulation system
- Player-to-player trading
- Economic balancing
- Advanced crafting recipes

### 9. Performance Optimization Strategies

#### Client-Side Optimization
```typescript
// LODManager.ts - Level of Detail system
export class LODManager {
  private lodLevels: Map<string, LODLevel[]> = new Map();
  
  constructor(private scene: Scene, private camera: Camera) {}
  
  registerMesh(meshId: string, highDetail: AbstractMesh, mediumDetail: AbstractMesh, lowDetail: AbstractMesh): void {
    this.lodLevels.set(meshId, [
      { distance: 0, mesh: highDetail },
      { distance: 500, mesh: mediumDetail },
      { distance: 2000, mesh: lowDetail }
    ]);
  }
  
  update(): void {
    const cameraPosition = this.camera.getAbsolutePosition();
    
    this.lodLevels.forEach((levels, meshId) => {
      levels.forEach((level, index) => {
        const distance = Vector3.Distance(cameraPosition, level.mesh.getAbsolutePosition());
        const shouldBeVisible = this.shouldMeshBeVisible(level, distance, levels, index);
        
        level.mesh.setEnabled(shouldBeVisible);
      });
    });
  }
  
  private shouldMeshBeVisible(level: LODLevel, distance: number, allLevels: LODLevel[], currentIndex: number): boolean {
    const nextLevel = allLevels[currentIndex + 1];
    return distance >= level.distance && (!nextLevel || distance < nextLevel.distance);
  }
}

// Frustum culling for large solar systems
export class FrustumCuller {
  private frustumPlanes: Plane[] = [];
  
  constructor(private camera: Camera) {}
  
  update(): void {
    this.frustumPlanes = Frustum.GetPlanes(this.camera.getTransformationMatrix());
  }
  
  isInFrustum(boundingSphere: BoundingSphere): boolean {
    for (const plane of this.frustumPlanes) {
      const distance = Vector3.Dot(plane.normal, boundingSphere.center) + plane.d;
      if (distance < -boundingSphere.radius) {
        return false;
      }
    }
    return true;
  }
}
```

#### Server-Side Optimization
```typescript
// Spatial partitioning for efficient collision detection
export class SpatialGrid {
  private grid: Map<string, Set<string>> = new Map();
  private cellSize: number = 1000; // units
  
  addObject(objectId: string, position: Vector3): void {
    const cellKey = this.getCellKey(position);
    if (!this.grid.has(cellKey)) {
      this.grid.set(cellKey, new Set());
    }
    this.grid.get(cellKey)!.add(objectId);
  }
  
  removeObject(objectId: string, position: Vector3): void {
    const cellKey = this.getCellKey(position);
    const cell = this.grid.get(cellKey);
    if (cell) {
      cell.delete(objectId);
      if (cell.size === 0) {
        this.grid.delete(cellKey);
      }
    }
  }
  
  getNearbyObjects(position: Vector3, radius: number): Set<string> {
    const nearby = new Set<string>();
    const cellsToCheck = this.getCellsInRadius(position, radius);
    
    cellsToCheck.forEach(cellKey => {
      const cell = this.grid.get(cellKey);
      if (cell) {
        cell.forEach(objectId => nearby.add(objectId));
      }
    });
    
    return nearby;
  }
  
  private getCellKey(position: Vector3): string {
    const x = Math.floor(position.x / this.cellSize);
    const y = Math.floor(position.y / this.cellSize);
    const z = Math.floor(position.z / this.cellSize);
    return `${x},${y},${z}`;
  }
}
```

### 10. Monitoring and Analytics

#### Performance Monitoring
```typescript
// PerformanceMonitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric> = new Map();
  private reportingInterval = 30000; // 30 seconds
  
  constructor() {
    setInterval(() => this.reportMetrics(), this.reportingInterval);
  }
  
  startMeasurement(name: string): void {
    this.metrics.set(name, {
      name,
      startTime: performance.now(),
      endTime: 0,
      duration: 0
    });
  }
  
  endMeasurement(name: string): number {
    const metric = this.metrics.get(name);
    if (metric) {
      metric.endTime = performance.now();
      metric.duration = metric.endTime - metric.startTime;
      return metric.duration;
    }
    return 0;
  }
  
  recordFrameTime(frameTime: number): void {
    // Track FPS and frame time distribution
    this.metrics.set('frame_time', {
      name: 'frame_time',
      value: frameTime,
      timestamp: Date.now()
    });
  }
  
  private async reportMetrics(): Promise<void> {
    const report = {
      timestamp: Date.now(),
      metrics: Array.from(this.metrics.values()),
      userAgent: navigator.userAgent,
      sessionId: this.getSessionId()
    };
    
    try {
      await fetch('/api/analytics/performance', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(report)
      });
    } catch (error) {
      console.warn('Failed to report performance metrics:', error);
    }
  }
}
```

### 11. Security Considerations

#### Input Validation and Sanitization
```typescript
// ValidationSchemas.ts
export const playerUpdateSchema = z.object({
  position: z.object({
    x: z.number().min(-100000).max(100000),
    y: z.number().min(-100000).max(100000),
    z: z.number().min(-100000).max(100000)
  }),
  rotation: z.object({
    x: z.number().min(-1).max(1),
    y: z.number().min(-1).max(1),
    z: z.number().min(-1).max(1),
    w: z.number().min(-1).max(1)
  }),
  velocity: z.object({
    x: z.number().min(-1000).max(1000),
    y: z.number().min(-1000).max(1000),
    z: z.number().min(-1000).max(1000)
  }),
  timestamp: z.number().min(Date.now() - 5000).max(Date.now() + 1000)
});

// Rate limiting for API endpoints
export class RateLimiter {
  private requests: Map<string, number[]> = new Map();
  
  isAllowed(clientId: string, maxRequests: number, windowMs: number): boolean {
    const now = Date.now();
    const windowStart = now - windowMs;
    
    if (!this.requests.has(clientId)) {
      this.requests.set(clientId, []);
    }
    
    const clientRequests = this.requests.get(clientId)!;
    
    // Remove old requests outside the window
    while (clientRequests.length > 0 && clientRequests[0] < windowStart) {
      clientRequests.shift();
    }
    
    // Check if under limit
    if (clientRequests.length >= maxRequests) {
      return false;
    }
    
    // Add current request
    clientRequests.push(now);
    return true;
  }
}
```

#### Authentication Security
```typescript
// AuthSecurity.ts
export class AuthSecurity {
  private static readonly SALT_ROUNDS = 12;
  private static readonly TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours
  
  static async hashPassword(password: string): Promise<string> {
    const salt = await bcrypt.genSalt(this.SALT_ROUNDS);
    return bcrypt.hash(password, salt);
  }
  
  static async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
  
  static async generateJWT(playerId: string, secret: string): Promise<string> {
    const payload = {
      sub: playerId,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor((Date.now() + this.TOKEN_EXPIRY) / 1000),
      iss: 'chronicles-synergistic-sphere'
    };
    
    return jwt.sign(payload, secret);
  }
  
  static async verifyJWT(token: string, secret: string): Promise<JWTPayload | null> {
    try {
      return jwt.verify(token, secret) as JWTPayload;
    } catch (error) {
      return null;
    }
  }
  
  // Prevent timing attacks on user enumeration
  static async safeUserLookup(identifier: string, db: D1Database): Promise<User | null> {
    const startTime = Date.now();
    
    const user = await db.prepare(
      'SELECT * FROM players WHERE email = ? OR username = ?'
    ).bind(identifier, identifier).first();
    
    // Ensure consistent timing regardless of user existence
    const minTime = 100; // minimum 100ms
    const elapsed = Date.now() - startTime;
    if (elapsed < minTime) {
      await new Promise(resolve => setTimeout(resolve, minTime - elapsed));
    }
    
    return user as User | null;
  }
}
```

### 12. Advanced AI and NPCs

#### Behavior Tree System for NPCs
```typescript
// BehaviorTree.ts
export abstract class BehaviorNode {
  abstract execute(context: NPCContext): BehaviorResult;
}

export class NPCBehaviorTree {
  constructor(private rootNode: BehaviorNode) {}
  
  update(npc: NPCState, context: NPCContext): void {
    const result = this.rootNode.execute(context);
    this.applyBehaviorResult(npc, result);
  }
  
  private applyBehaviorResult(npc: NPCState, result: BehaviorResult): void {
    switch (result.action) {
      case 'move_to':
        npc.targetPosition = result.target;
        npc.currentAction = 'moving';
        break;
      case 'attack':
        npc.targetId = result.targetId;
        npc.currentAction = 'attacking';
        break;
      case 'patrol':
        npc.patrolRoute = result.patrolPoints;
        npc.currentAction = 'patrolling';
        break;
      case 'idle':
        npc.currentAction = 'idle';
        break;
    }
  }
}

// Specific behavior implementations
export class PatrolBehavior extends BehaviorNode {
  constructor(private patrolPoints: Vector3[], private speed: number = 50) {
    super();
  }
  
  execute(context: NPCContext): BehaviorResult {
    const npc = context.npc;
    
    if (!npc.currentPatrolIndex) {
      npc.currentPatrolIndex = 0;
    }
    
    const targetPoint = this.patrolPoints[npc.currentPatrolIndex];
    const distance = Vector3.Distance(npc.position, targetPoint);
    
    if (distance < 10) {
      // Reached patrol point, move to next
      npc.currentPatrolIndex = (npc.currentPatrolIndex + 1) % this.patrolPoints.length;
    }
    
    return {
      action: 'move_to',
      target: targetPoint,
      speed: this.speed
    };
  }
}

export class DefendAreaBehavior extends BehaviorNode {
  constructor(private defendPosition: Vector3, private defendRadius: number = 500) {
    super();
  }
  
  execute(context: NPCContext): BehaviorResult {
    const npc = context.npc;
    const threats = context.nearbyPlayers.filter(p => 
      Vector3.Distance(p.position, this.defendPosition) < this.defendRadius
    );
    
    if (threats.length > 0) {
      const closestThreat = threats.reduce((closest, current) => 
        Vector3.Distance(current.position, npc.position) < 
        Vector3.Distance(closest.position, npc.position) ? current : closest
      );
      
      return {
        action: 'attack',
        targetId: closestThreat.id
      };
    }
    
    // No threats, patrol the area
    const patrolRadius = this.defendRadius * 0.8;
    const angle = (Date.now() / 10000) % (Math.PI * 2); // Slow circular patrol
    const patrolPoint = new Vector3(
      this.defendPosition.x + Math.cos(angle) * patrolRadius,
      this.defendPosition.y,
      this.defendPosition.z + Math.sin(angle) * patrolRadius
    );
    
    return {
      action: 'move_to',
      target: patrolPoint,
      speed: 30
    };
  }
}
```

#### Dynamic Event System
```typescript
// EventSystem.ts
export class DynamicEventSystem {
  private activeEvents: Map<string, GameEvent> = new Map();
  private eventTemplates: EventTemplate[] = [];
  
  constructor(private partyServer: SolarSystemServer) {
    this.loadEventTemplates();
    this.startEventLoop();
  }
  
  private loadEventTemplates(): void {
    this.eventTemplates = [
      {
        id: 'pirate_raid',
        name: 'Pirate Raid',
        probability: 0.05, // 5% chance per hour
        conditions: {
          minPlayers: 2,
          systemTypes: ['frontier', 'contested'],
          cooldown: 3600000 // 1 hour
        },
        spawn: this.spawnPirateRaid.bind(this),
        duration: 600000 // 10 minutes
      },
      {
        id: 'resource_anomaly',
        name: 'Resource Anomaly',
        probability: 0.1,
        conditions: {
          minPlayers: 1,
          systemTypes: ['any'],
          cooldown: 1800000 // 30 minutes
        },
        spawn: this.spawnResourceAnomaly.bind(this),
        duration: 1200000 // 20 minutes
      },
      {
        id: 'ancient_artifact',
        name: 'Ancient Artifact Discovery',
        probability: 0.02,
        conditions: {
          minPlayers: 1,
          systemTypes: ['ancient', 'mysterious'],
          cooldown: 7200000 // 2 hours
        },
        spawn: this.spawnArtifactDiscovery.bind(this),
        duration: 1800000 // 30 minutes
      }
    ];
  }
  
  private startEventLoop(): void {
    setInterval(() => {
      this.checkForNewEvents();
      this.updateActiveEvents();
    }, 60000); // Check every minute
  }
  
  private checkForNewEvents(): void {
    const systemState = this.partyServer.getGameState();
    const playerCount = systemState.players.size;
    
    this.eventTemplates.forEach(template => {
      if (this.shouldTriggerEvent(template, systemState, playerCount)) {
        this.triggerEvent(template);
      }
    });
  }
  
  private shouldTriggerEvent(template: EventTemplate, systemState: SolarSystemState, playerCount: number): boolean {
    // Check basic conditions
    if (playerCount < template.conditions.minPlayers) return false;
    
    // Check cooldown
    const lastEvent = this.getLastEventTime(template.id);
    if (lastEvent && Date.now() - lastEvent < template.conditions.cooldown) return false;
    
    // Check system type compatibility
    if (template.conditions.systemTypes.length > 0 && 
        !template.conditions.systemTypes.includes('any') &&
        !template.conditions.systemTypes.includes(systemState.type)) {
      return false;
    }
    
    // Random probability check
    return Math.random() < template.probability;
  }
  
  private triggerEvent(template: EventTemplate): void {
    const eventId = generateUUID();
    const gameEvent: GameEvent = {
      id: eventId,
      templateId: template.id,
      name: template.name,
      startTime: Date.now(),
      endTime: Date.now() + template.duration,
      active: true,
      participants: new Set(),
      data: {}
    };
    
    // Spawn event entities/effects
    template.spawn(gameEvent);
    
    this.activeEvents.set(eventId, gameEvent);
    
    // Notify all players
    this.partyServer.broadcastEvent({
      type: 'event_started',
      event: gameEvent
    });
  }
  
  private spawnPirateRaid(event: GameEvent): void {
    const systemState = this.partyServer.getGameState();
    const spawnPoint = this.getRandomSpawnPoint();
    
    // Spawn pirate ships
    const pirateCount = Math.min(systemState.players.size + 1, 5);
    for (let i = 0; i < pirateCount; i++) {
      const pirateId = `pirate-${event.id}-${i}`;
      const pirate: NPCState = {
        id: pirateId,
        type: 'pirate_fighter',
        position: spawnPoint.clone().add(new Vector3(
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200
        )),
        rotation: Quaternion.Identity(),
        health: 100,
        maxHealth: 100,
        behavior: 'aggressive',
        targetType: 'player',
        weapons: ['laser_cannon', 'plasma_torpedo'],
        loot: this.generatePirateLoot(),
        eventId: event.id
      };
      
      systemState.npcs.set(pirateId, pirate);
    }
    
    event.data.pirateIds = Array.from(systemState.npcs.keys()).filter(id => id.startsWith(`pirate-${event.id}`));
  }
  
  private spawnResourceAnomaly(event: GameEvent): void {
    const anomalyPosition = this.getRandomSpawnPoint();
    
    const anomaly: ResourceAnomaly = {
      id: `anomaly-${event.id}`,
      position: anomalyPosition,
      type: 'exotic_matter',
      intensity: Math.random() * 0.5 + 0.5, // 50-100% intensity
      radius: 150,
      resourceYield: Math.floor(Math.random() * 500) + 100,
      harvestDifficulty: Math.random() * 0.8 + 0.2,
      eventId: event.id
    };
    
    this.partyServer.addResourceAnomaly(anomaly);
    event.data.anomalyId = anomaly.id;
  }
  
  private spawnArtifactDiscovery(event: GameEvent): void {
    const artifactPosition = this.getRandomSpawnPoint();
    
    const artifact: AncientArtifact = {
      id: `artifact-${event.id}`,
      position: artifactPosition,
      type: 'knowledge_core',
      rarity: Math.random() < 0.1 ? 'legendary' : 'rare',
      researchTimeRequired: 300000, // 5 minutes
      collaborativeBonus: true, // Multiple players can research together
      knowledgeReward: {
        fragmentCount: Math.random() < 0.3 ? 2 : 1,
        guaranteedTypes: ['ancient_technology'],
        bonusChance: 0.2
      },
      eventId: event.id
    };
    
    this.partyServer.addArtifact(artifact);
    event.data.artifactId = artifact.id;
  }
}
```

### 13. Advanced Procedural Generation

#### Improved Stellar and Planetary Generation
```typescript
// AdvancedSystemGenerator.ts
export class AdvancedSystemGenerator extends SystemGenerator {
  private stellarEvolution: StellarEvolutionModel;
  private planetaryFormation: PlanetaryFormationModel;
  private biosphereGenerator: BiosphereGenerator;
  
  constructor(systemId: string) {
    super(systemId);
    this.stellarEvolution = new StellarEvolutionModel();
    this.planetaryFormation = new PlanetaryFormationModel();
    this.biosphereGenerator = new BiosphereGenerator();
  }
  
  generateAdvanced(): DetailedSolarSystemData {
    const basicSystem = this.generate();
    
    // Enhanced stellar characteristics
    const detailedStar = this.stellarEvolution.evolve(basicSystem.star);
    
    // Planetary system formation simulation
    const formationHistory = this.planetaryFormation.simulate(detailedStar);
    
    // Enhanced planets with geological history
    const detailedPlanets = basicSystem.planets.map(planet => 
      this.enhancePlanet(planet, detailedStar, formationHistory)
    );
    
    // Generate space phenomena
    const phenomena = this.generateSpacePhenomena(detailedStar, detailedPlanets);
    
    return {
      ...basicSystem,
      star: detailedStar,
      planets: detailedPlanets,
      phenomena,
      formationHistory,
      uniqueFeatures: this.generateUniqueFeatures(detailedStar, detailedPlanets)
    };
  }
  
  private enhancePlanet(planet: PlanetData, star: DetailedStarData, formation: FormationHistory): DetailedPlanetData {
    // Geological evolution
    const geology = this.simulateGeology(planet, star, formation);
    
    // Atmospheric evolution
    const atmosphere = this.simulateAtmosphericEvolution(planet, star, geology);
    
    // Potential biosphere
    const biosphere = this.biosphereGenerator.attempt(planet, star, atmosphere);
    
    // Resource distribution based on geological processes
    const resources = this.distributeResources(planet, geology);
    
    // Generate points of interest
    const pointsOfInterest = this.generatePOIs(planet, geology, biosphere);
    
    return {
      ...planet,
      geology,
      detailedAtmosphere: atmosphere,
      biosphere,
      resources,
      pointsOfInterest,
      explorationSites: this.generateExplorationSites(planet, pointsOfInterest),
      weatherPatterns: this.generateWeatherPatterns(planet, atmosphere)
    };
  }
  
  private simulateGeology(planet: PlanetData, star: DetailedStarData, formation: FormationHistory): GeologyData {
    const age = star.age * 1e9; // Convert to years
    const tidalForces = this.calculateTidalForces(planet, star);
    
    // Plate tectonics simulation
    const plateActivity = this.calculatePlateActivity(planet, age, tidalForces);
    
    // Volcanic activity
    const volcanicActivity = this.calculateVolcanicActivity(planet, plateActivity, age);
    
    // Impact crater distribution
    const impactHistory = this.simulateImpactHistory(planet, formation, age);
    
    return {
      plateActivity,
      volcanicActivity,
      impactHistory,
      mineralDistribution: this.calculateMineralDistribution(planet, volcanicActivity, impactHistory),
      surfaceFeatures: this.generateSurfaceFeatures(planet, plateActivity, volcanicActivity),
      coreComposition: this.determineCoreComposition(planet, formation),
      magneticField: this.calculateMagneticField(planet, age)
    };
  }
  
  private generateExplorationSites(planet: DetailedPlanetData, pois: PointOfInterest[]): ExplorationSite[] {
    const sites: ExplorationSite[] = [];
    
    // Ancient ruins
    if (Math.random() < this.calculateRuinsProbability(planet)) {
      sites.push(...this.generateAncientRuins(planet));
    }
    
    // Resource deposits
    planet.resources.forEach(resource => {
      if (resource.richness > 0.7) { // High-value deposits
        sites.push({
          id: generateUUID(),
          type: 'resource_deposit',
          position: resource.position,
          difficulty: this.calculateExtractionDifficulty(resource, planet),
          rewards: {
            resources: [{ type: resource.type, quantity: resource.estimatedYield }],
            experience: Math.floor(resource.richness * 100),
            possibleDiscoveries: this.getResourceDiscoveries(resource.type)
          },
          requirements: {
            equipment: this.getRequiredEquipment(resource.type),
            skills: this.getRequiredSkills(resource.type),
            time: this.getExtractionTime(resource, planet)
          }
        });
      }
    });
    
    // Scientific anomalies
    if (planet.biosphere?.complexity > 0.5) {
      sites.push(...this.generateBiologicalSites(planet));
    }
    
    return sites;
  }
}

// Biosphere generation system
export class BiosphereGenerator {
  attempt(planet: PlanetData, star: DetailedStarData, atmosphere: DetailedAtmosphereData): BiosphereData | null {
    const habitabilityScore = this.calculateHabitability(planet, star, atmosphere);
    
    if (habitabilityScore < 0.1) return null; // No life possible
    
    const complexity = this.calculateComplexity(habitabilityScore, star.age, planet);
    const diversity = this.calculateDiversity(complexity, planet, atmosphere);
    
    const ecosystems = this.generateEcosystems(planet, atmosphere, complexity);
    const species = this.generateSpecies(ecosystems, diversity, complexity);
    
    return {
      complexity,
      diversity,
      ecosystems,
      species,
      evolutionaryHistory: this.generateEvolutionaryHistory(star.age, complexity),
      extinctionEvents: this.simulateExtinctionEvents(planet, star),
      currentDominantLife: this.determineDominantLifeforms(species, complexity)
    };
  }
  
  private generateSpecies(ecosystems: Ecosystem[], diversity: number, complexity: number): Species[] {
    const species: Species[] = [];
    const speciesCount = Math.floor(diversity * complexity * 1000);
    
    ecosystems.forEach(ecosystem => {
      const ecosystemSpeciesCount = Math.floor(speciesCount * ecosystem.biodiversityIndex);
      
      for (let i = 0; i < ecosystemSpeciesCount; i++) {
        species.push({
          id: generateUUID(),
          name: this.generateSpeciesName(),
          type: this.rng.choice(['microorganism', 'plant', 'herbivore', 'carnivore', 'omnivore']),
          size: this.generateSize(),
          habitat: ecosystem.type,
          intelligence: this.calculateIntelligence(complexity),
          rarity: this.calculateRarity(ecosystem, complexity),
          traits: this.generateTraits(),
          evolutionaryNiche: this.determineNiche(ecosystem),
          culturalArtifacts: this.generateCulturalArtifacts(complexity)
        });
      }
    });
    
    return species;
  }
}
```

### 14. Advanced UI/UX Systems

#### Immersive HUD System
```typescript
// ImmersiveHUD.tsx
export const ImmersiveHUD: React.FC = () => {
  const { player, ship, currentSystem } = useGameStore();
  const { scanResults, targetingData } = usePlayerSystems();
  const [hudMode, setHudMode] = useState<'normal' | 'tactical' | 'exploration'>('normal');
  
  return (
    <div className="fixed inset-0 pointer-events-none">
      {/* Ship Status Display */}
      <ShipStatusHologram ship={ship} className="absolute top-4 left-4" />
      
      {/* Targeting Reticle */}
      <TargetingSystem data={targetingData} className="absolute inset-0" />
      
      {/* Scan Results Overlay */}
      {scanResults && (
        <ScanResultsDisplay 
          results={scanResults} 
          className="absolute top-4 right-4"
          onKnowledgeFragment={(fragment) => showKnowledgeModal(fragment)}
        />
      )}
      
      {/* Navigation Compass */}
      <Navigation3DCompass 
        currentSystem={currentSystem}
        className="absolute bottom-4 right-4"
      />
      
      {/* Chat and Communication */}
      <CommunicationPanel className="absolute bottom-4 left-4" />
      
      {/* Mode-specific overlays */}
      {hudMode === 'tactical' && <TacticalOverlay />}
      {hudMode === 'exploration' && <ExplorationOverlay />}
    </div>
  );
};

// 3D Holographic Ship Status
const ShipStatusHologram: React.FC<{ ship: ShipData }> = ({ ship }) => {
  const [hologramRef, setHologramRef] = useState<HTMLDivElement | null>(null);
  
  useEffect(() => {
    if (!hologramRef) return;
    
    // Create miniature 3D ship model using Three.js
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 200/150, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    
    renderer.setSize(200, 150);
    renderer.setClearColor(0x000000, 0);
    hologramRef.appendChild(renderer.domElement);
    
    // Load ship model
    const loader = new GLTFLoader();
    loader.load(`/models/ships/${ship.class}.glb`, (gltf) => {
      const shipModel = gltf.scene;
      shipModel.scale.setScalar(0.1);
      scene.add(shipModel);
      
      // Add damage visualization
      this.visualizeDamage(shipModel, ship);
      
      // Add holographic effect
      this.addHolographicEffect(shipModel);
      
      // Animate rotation
      const animate = () => {
        shipModel.rotation.y += 0.01;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      };
      animate();
    });
    
    camera.position.z = 5;
    
    return () => {
      if (hologramRef.contains(renderer.domElement)) {
        hologramRef.removeChild(renderer.domElement);
      }
    };
  }, [hologramRef, ship]);
  
  return (
    <div className="bg-black/30 border border-cyan-400/50 rounded-lg p-4 pointer-events-auto">
      <div ref={setHologramRef} className="mb-2" />
      
      <div className="space-y-2 text-xs font-mono text-cyan-400">
        <StatusBar 
          label="HULL" 
          value={ship.hullPoints} 
          max={ship.maxHullPoints}
          color="red"
        />
        <StatusBar 
          label="SHLD" 
          value={ship.shieldPoints} 
          max={ship.maxShieldPoints}
          color="blue"
        />
        <StatusBar 
          label="ENRG" 
          value={ship.energyPoints} 
          max={ship.maxEnergyPoints}
          color="yellow"
        />
      </div>
    </div>
  );
};

// Advanced Targeting System
const TargetingSystem: React.FC<{ data: TargetingData }> = ({ data }) => {
  const [reticlePosition, setReticlePosition] = useState({ x: 0, y: 0 });
  const [lockStrength, setLockStrength] = useState(0);
  
  useEffect(() => {
    if (data.currentTarget) {
      // Convert 3D world position to screen coordinates
      const screenPos = worldToScreen(data.currentTarget.position);
      setReticlePosition(screenPos);
      
      // Calculate lock strength based on distance and target movement
      const distance = Vector3.Distance(data.playerPosition, data.currentTarget.position);
      const speed = data.currentTarget.velocity.length();
      const lockStr = Math.max(0, 1 - (distance / 1000) - (speed / 100));
      setLockStrength(lockStr);
    }
  }, [data]);
  
  if (!data.currentTarget) return null;
  
  return (
    <div className="absolute inset-0">
      {/* Main targeting reticle */}
      <div 
        className="absolute transform -translate-x-1/2 -translate-y-1/2"
        style={{ left: reticlePosition.x, top: reticlePosition.y }}
      >
        <svg width="100" height="100" viewBox="0 0 100 100">
          {/* Animated targeting circles */}
          <circle
            cx="50"
            cy="50"
            r="40"
            fill="none"
            stroke={lockStrength > 0.8 ? '#00ff00' : lockStrength > 0.4 ? '#ffff00' : '#ff0000'}
            strokeWidth="2"
            strokeDasharray="10,5"
            className="animate-spin"
          />
          <circle
            cx="50"
            cy="50"
            r="25"
            fill="none"
            stroke="cyan"
            strokeWidth="1"
            strokeDasharray={`${lockStrength * 157}, 157`}
            className="transition-all duration-300"
          />
          
          {/* Target info */}
          <text x="60" y="20" fill="cyan" fontSize="8" fontFamily="monospace">
            {data.currentTarget.name}
          </text>
          <text x="60" y="30" fill="yellow" fontSize="6" fontFamily="monospace">
            {Math.floor(Vector3.Distance(data.playerPosition, data.currentTarget.position))}m
          </text>
        </svg>
      </div>
      
      {/* Leading indicator for moving targets */}
      {data.currentTarget.velocity.length() > 0 && (
        <div 
          className="absolute transform -translate-x-1/2 -translate-y-1/2"
          style={{ 
            left: reticlePosition.x + data.leadingIndicator.x, 
            top: reticlePosition.y + data.leadingIndicator.y 
          }}
        >
          <div className="w-4 h-4 border-2 border-orange-400 rotate-45" />
        </div>
      )}
    </div>
  );
};
```

#### Knowledge Graph Visualization
```typescript
// KnowledgeGraphViz.tsx
export const KnowledgeGraphVisualization: React.FC = () => {
  const { discoveredFragments } = useKnowledgeStore();
  const [selectedFragment, setSelectedFragment] = useState<string | null>(null);
  const [view3D, setView3D] = useState(false);
  
  useEffect(() => {
    if (view3D) {
      initializeForceDirectedGraph3D();
    } else {
      initializeForceDirectedGraph2D();
    }
  }, [view3D, discoveredFragments]);
  
  const initializeForceDirectedGraph3D = () => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    
    // Create nodes for each knowledge fragment
    const nodes = discoveredFragments.map(fragment => ({
      id: fragment.id,
      position: new THREE.Vector3(
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100,
        (Math.random() - 0.5) * 100
      ),
      fragment,
      mesh: createNodeMesh(fragment)
    }));
    
    // Create connections based on prerequisites/unlocks
    const connections = this.calculateConnections(discoveredFragments);
    
    // Apply force-directed layout
    this.applyForceDirectedLayout3D(nodes, connections);
    
    // Add interactive capabilities
    this.addNodeInteraction(nodes, camera, renderer);
  };
  
  const createNodeMesh = (fragment: KnowledgeFragment): THREE.Mesh => {
    const geometry = this.getGeometryForFragmentType(fragment.type);
    const material = new THREE.MeshPhongMaterial({ 
      color: this.getColorForRarity(fragment.rarity),
      emissive: this.getEmissiveColorForType(fragment.type),
      transparent: true,
      opacity: 0.8
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add pulsing animation for new discoveries
    if (this.isRecentDiscovery(fragment)) {
      this.addPulsingAnimation(mesh);
    }
    
    return mesh;
  };
  
  return (
    <div className="fixed inset-0 bg-black/90 z-50">
      <div className="absolute top-4 left-4 space-x-4">
        <button 
          onClick={() => setView3D(!view3D)}
          className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded"
        >
          {view3D ? '2D View' : '3D View'}
        </button>
        
        <button 
          onClick={this.filterByType}
          className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded"
        >
          Filter by Type
        </button>
      </div>
      
      {/* Fragment details panel */}
      {selectedFragment && (
        <FragmentDetailsPanel 
          fragment={discoveredFragments.find(f => f.id === selectedFragment)}
          onClose={() => setSelectedFragment(null)}
          onViewRelated={this.highlightRelatedFragments}
        />
      )}
      
      {/* Graph canvas */}
      <div id="knowledge-graph-canvas" className="w-full h-full" />
      
      {/* Stats overlay */}
      <div className="absolute bottom-4 right-4 bg-black/60 p-4 rounded">
        <div className="text-cyan-400 text-sm space-y-1">
          <div>Total Fragments: {discoveredFragments.length}</div>
          <div>Completion: {this.calculateCompletionPercentage()}%</div>
          <div>Rarest Discovery: {this.getRarestDiscovery()?.title}</div>
        </div>
      </div>
    </div>
  );
};

// Fragment Details Panel
const FragmentDetailsPanel: React.FC<{
  fragment: KnowledgeFragment;
  onClose: () => void;
  onViewRelated: (fragmentId: string) => void;
}> = ({ fragment, onClose, onViewRelated }) => {
  return (
    <div className="absolute top-4 right-4 w-96 bg-black/80 border border-cyan-400/50 rounded-lg p-6">
      <div className="flex justify-between items-start mb-4">
        <h3 className="text-cyan-400 text-lg font-bold">{fragment.title}</h3>
        <button onClick={onClose} className="text-red-400 hover:text-red-300">×</button>
      </div>
      
      <div className="space-y-3">
        <div className="flex space-x-4">
          <span className={`px-2 py-1 rounded text-xs ${getRarityClass(fragment.rarity)}`}>
            {fragment.rarity.toUpperCase()}
          </span>
          <span className={`px-2 py-1 rounded text-xs ${getTypeClass(fragment.type)}`}>
            {fragment.type.replace('_', ' ').toUpperCase()}
          </span>
        </div>
        
        <div className="text-gray-300 text-sm">
          {fragment.content}
        </div>
        
        <div className="text-xs text-gray-400">
          <div>Discovered by: {fragment.discoveredBy}</div>
          <div>Location: {fragment.discoveryLocation}</div>
          <div>Date: {new Date(fragment.discoveredAt).toLocaleDateString()}</div>
        </div>
        
        {fragment.prerequisites.length > 0 && (
          <div className="border-t border-gray-600 pt-2">
            <div className="text-sm text-cyan-400 mb-1">Prerequisites:</div>
            {fragment.prerequisites.map(prereq => (
              <button
                key={prereq}
                onClick={() => onViewRelated(prereq)}
                className="block text-xs text-blue-400 hover:text-blue-300"
              >
                → {getFragmentTitle(prereq)}
              </button>
            ))}
          </div>
        )}
        
        {fragment.unlocks.length > 0 && (
          <div className="border-t border-gray-600 pt-2">
            <div className="text-sm text-green-400 mb-1">Unlocks:</div>
            {fragment.unlocks.map(unlock => (
              <button
                key={unlock}
                onClick={() => onViewRelated(unlock)}
                className="block text-xs text-green-400 hover:text-green-300"
              >
                → {getFragmentTitle(unlock)}
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};
```

### 15. Advanced Multiplayer Features

#### Guild and Alliance System
```typescript
// GuildSystem.ts
export class GuildSystem {
  constructor(private db: D1Database, private partyKit: PartyKitServer) {}
  
  async createGuild(founderId: string, guildData: CreateGuildData): Promise<Guild> {
    const guildId = generateUUID();
    
    const guild: Guild = {
      id: guildId,
      name: guildData.name,
      description: guildData.description,
      founderId,
      members: [{ 
        playerId: founderId, 
        rank: 'leader', 
        joinedAt: new Date().toISOString(),
        permissions: ALL_PERMISSIONS 
      }],
      treasury: 0,
      reputation: 0,
      territory: [],
      technologies: [],
      activeProjects: [],
      diplomacy: new Map(),
      createdAt: new Date().toISOString()
    };
    
    // Save to database
    await this.db.prepare(`
      INSERT INTO guilds (id, name, description, founder_id, data, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `).bind(
      guildId,
      guild.name,
      guild.description,
      founderId,
      JSON.stringify(guild),
      guild.createdAt
    ).run();
    
    // Create guild communication channel
    await this.createGuildChannel(guildId);
    
    return guild;
  }
  
  async joinGuild(playerId: string, guildId: string, inviteCode?: string): Promise<boolean> {
    const guild = await this.getGuild(guildId);
    if (!guild) return false;
    
    // Check if invitation is required
    if (guild.inviteOnly && !inviteCode) {
      return false;
    }
    
    // Verify invite code if provided
    if (inviteCode && !await this.verifyInviteCode(guildId, inviteCode)) {
      return false;
    }
    
    // Add member
    guild.members.push({
      playerId,
      rank: 'member',
      joinedAt: new Date().toISOString(),
      permissions: BASIC_PERMISSIONS
    });
    
    await this.updateGuild(guild);
    
    // Notify guild members
    this.notifyGuildMembers(guildId, {
      type: 'member_joined',
      playerId,
      timestamp: Date.now()
    });
    
    return true;
  }
  
  async initiateGuildProject(guildId: string, initiatorId: string, project: GuildProject): Promise<boolean> {
    const guild = await this.getGuild(guildId);
    if (!guild) return false;
    
    // Check permissions
    if (!this.hasPermission(guild, initiatorId, 'initiate_projects')) {
      return false;
    }
    
    // Check resource requirements
    if (!this.canAffordProject(guild, project)) {
      return false;
    }
    
    // Start project
    const activeProject: ActiveGuildProject = {
      ...project,
      id: generateUUID(),
      initiatedBy: initiatorId,
      startedAt: new Date().toISOString(),
      contributors: [],
      progress: 0,
      resourcesInvested: {}
    };
    
    guild.activeProjects.push(activeProject);
    await this.updateGuild(guild);
    
    // Notify members
    this.notifyGuildMembers(guildId, {
      type: 'project_started',
      project: activeProject
    });
    
    return true;
  }
}

// Collaborative Research System
export class CollaborativeResearch {
  private researchSessions: Map<string, ResearchSession> = new Map();
  
  async startResearchSession(artifact: AncientArtifact, initiatorId: string): Promise<string> {
    const sessionId = generateUUID();
    
    const session: ResearchSession = {
      id: sessionId,
      artifactId: artifact.id,
      initiatorId,
      participants: [{ playerId: initiatorId, contributionLevel: 0 }],
      progress: 0,
      startTime: Date.now(),
      maxDuration: artifact.researchTimeRequired,
      collaborativeBonus: 1.0,
      discoveries: [],
      active: true
    };
    
    this.researchSessions.set(sessionId, session);
    
    // Broadcast research opportunity to nearby players
    this.broadcastResearchOpportunity(artifact, session);
    
    return sessionId;
  }
  
  async joinResearchSession(sessionId: string, playerId: string): Promise<boolean> {
    const session = this.researchSessions.get(sessionId);
    if (!session || !session.active) return false;
    
    // Check if player is in range
    if (!this.isPlayerInRange(playerId, session)) return false;
    
    // Add participant
    session.participants.push({
      playerId,
      contributionLevel: 0,
      joinedAt: Date.now()
    });
    
    // Recalculate collaborative bonus
    session.collaborativeBonus = this.calculateCollaborativeBonus(session.participants.length);
    
    // Notify all participants
    this.notifyResearchParticipants(session, {
      type: 'participant_joined',
      playerId
    });
    
    return true;
  }
  
  updateResearchProgress(sessionId: string, playerId: string, contribution: number): void {
    const session = this.researchSessions.get(sessionId);
    if (!session || !session.active) return;
    
    const participant = session.participants.find(p => p.playerId === playerId);
    if (!participant) return;
    
    participant.contributionLevel += contribution;
    
    // Calculate total progress with collaborative bonus
    const totalContribution = session.participants.reduce((sum, p) => sum + p.contributionLevel, 0);
    session.progress = Math.min(1.0, totalContribution * session.collaborativeBonus / 100);
    
    // Check for breakthrough moments
    if (this.shouldTriggerBreakthrough(session)) {
      this.triggerResearchBreakthrough(session);
    }
    
    // Check completion
    if (session.progress >= 1.0) {
      this.completeResearch(session);
    }
    
    // Notify participants of progress
    this.notifyResearchParticipants(session, {
      type: 'progress_update',
      progress: session.progress,
      contributor: playerId
    });
  }
  
  private triggerResearchBreakthrough(session: ResearchSession): void {
    const breakthrough = this.generateBreakthrough(session);
    session.discoveries.push(breakthrough);
    
    // Temporary research speed boost
    session.collaborativeBonus *= 1.5;
    
    this.notifyResearchParticipants(session, {
      type: 'breakthrough',
      discovery: breakthrough
    });
  }
  
  private completeResearch(session: ResearchSession): void {
    session.active = false;
    session.completedAt = Date.now();
    
    // Generate final discoveries based on participation
    const finalDiscoveries = this.generateFinalDiscoveries(session);
    
    // Distribute rewards to participants
    session.participants.forEach(participant => {
      this.distributeResearchRewards(participant, session, finalDiscoveries);
    });
    
    this.notifyResearchParticipants(session, {
      type: 'research_completed',
      discoveries: finalDiscoveries
    });
  }
}
```

#### Advanced Communication System
```typescript
// CommunicationSystem.tsx
export const AdvancedCommunicationSystem: React.FC = () => {
  const [activeChannels, setActiveChannels] = useState<CommunicationChannel[]>([]);
  const [proximityPlayers, setProximityPlayers] = useState<Player[]>([]);
  const [selectedChannel, setSelectedChannel] = useState<string>('local');
  
  useEffect(() => {
    // Setup communication channels
    initializeCommunicationChannels();
    
    // Listen for proximity changes
    const proximityListener = setupProximityListener();
    
    return () => proximityListener.cleanup();
  }, []);
  
  const sendMessage = async (channelId: string, message: string, type: MessageType = 'text') => {
    const channel = activeChannels.find(c => c.id === channelId);
    if (!channel) return;
    
    const messageData: ChatMessage = {
      id: generateUUID(),
      senderId: getCurrentPlayerId(),
      channelId,
      content: message,
      type,
      timestamp: Date.now(),
      metadata: {
        location: getCurrentPlayerLocation(),
        priority: this.getMessagePriority(type),
        encryption: channel.encrypted
      }
    };
    
    // Apply channel-specific rules
    if (channel.type === 'proximity') {
      messageData.range = PROXIMITY_CHAT_RANGE;
      messageData.attenuation = true;
    } else if (channel.type === 'guild') {
      messageData.guildId = getCurrentPlayerGuild();
    } else if (channel.type === 'system') {
      messageData.systemId = getCurrentSystem();
    }
    
    await sendChatMessage(messageData);
  };
  
  const handleVoiceChat = (channelId: string, enabled: boolean) => {
    if (enabled) {
      startVoiceChat(channelId, {
        spatialAudio: channelId === 'local',
        compression: 'opus',
        noiseReduction: true,
        echoCancellation: true
      });
    } else {
      stopVoiceChat(channelId);
    }
  };
  
  return (
    <div className="fixed bottom-4 left-4 w-96 bg-black/80 border border-cyan-400/50 rounded-lg">
      {/* Channel tabs */}
      <div className="flex border-b border-gray-600">
        {activeChannels.map(channel => (
          <button
            key={channel.id}
            onClick={() => setSelectedChannel(channel.id)}
            className={`px-3 py-2 text-xs ${
              selectedChannel === channel.id 
                ? 'bg-cyan-600 text-white' 
                : 'text-gray-400 hover:text-white'
            }`}
          >
            {channel.name}
            {channel.unreadCount > 0 && (
              <span className="ml-1 bg-red-500 text-white text-xs rounded-full px-1">
                {channel.unreadCount}
              </span>
            )}
          </button>
        ))}
      </div>
      
      {/* Message area */}
      <div className="h-48 overflow-y-auto p-2 space-y-1">
        {getChannelMessages(selectedChannel).map(message => (
          <ChatMessageComponent key={message.id} message={message} />
        ))}
      </div>
      
      {/* Input area */}
      <div className="border-t border-gray-600 p-2">
        <div className="flex space-x-2">
          <input
            type="text"
            placeholder={`Message ${getChannelName(selectedChannel)}...`}
            className="flex-1 bg